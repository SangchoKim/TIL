# 10/18 - **마이크로 프론트엔드를 통합**하는 주요 기법

# **서버 측 템플릿 조합 (Server-side Composition)**

서버 측에서 각 마이크로 프론트엔드 모듈을 **템플릿**으로 조합하는 방식입니다. 각 마이크로 프론트엔드는 독립적인 HTML 조각이나 UI 컴포넌트를 서버에서 반환하며, 최종 HTML 페이지가 서버에서 조합되어 클라이언트로 전달됩니다.

### **작동 방식**

- 서버는 요청을 수신하면 여러 마이크로 프론트엔드 모듈을 각기 다른 경로에서 가져와 하나의 HTML 페이지로 결합합니다.
- 서버에서 HTML 조각을 모두 결합하여 최종 페이지를 만들어 클라이언트에 전달하므로, 초기 페이지 로딩 시간이 빠르고 SEO 친화적입니다.

### **장점**

- 서버에서 페이지를 조합하므로 SEO와 성능에 유리합니다.
- 서버가 전체 조합 과정을 담당하므로 클라이언트의 복잡성이 줄어듭니다.

### **단점**

- 서버 측 로직이 복잡해질 수 있으며, 각 마이크로 프론트엔드가 서버에 적절히 배포되고 호환성을 유지하는 데 주의해야 합니다.
- 클라이언트에서 인터랙티브한 동작을 위해 추가적인 클라이언트 측 로직이 필요할 수 있습니다.

### **사용 사례**

- SSR(Server Side Rendering) 애플리케이션.
- 페이지 로딩 성능이 중요하고 SEO 최적화가 중요한 경우.

# **빌드 타임 통합 (Build-time Integration)**

각 마이크로 프론트엔드를 독립적으로 빌드한 후, **빌드 타임**에 여러 모듈을 통합하는 방식입니다. 즉, 모든 모듈이 빌드 시점에 결합되어 하나의 번들로 생성됩니다.

### **작동 방식**

- 여러 팀이 각기 독립적으로 마이크로 프론트엔드 모듈을 개발하고 빌드합니다.
- 이 빌드된 결과물들은 중앙 빌드 시스템에서 통합되어 하나의 완전한 애플리케이션으로 번들링됩니다.

### **장점**

- 런타임 복잡성이 낮아지고, 번들 크기를 최적화할 수 있습니다.
- 성능이 뛰어나고, 코드 중복을 최소화할 수 있습니다.

### **단점**

- 빌드 타임에 모든 모듈을 통합해야 하므로, 각 모듈의 변경 사항이 전체 애플리케이션 빌드에 영향을 미칠 수 있습니다.
- 마이크로 프론트엔드의 독립적인 배포가 어렵습니다. 모든 모듈을 한 번에 배포해야 합니다.

### **사용 사례**

- 코드 중복을 최소화하고 성능을 극대화해야 하는 경우.
- 변경 빈도가 낮은 대규모 프로젝트.

# **클라이언트 측 통합 (Client-side Composition)**

**클라이언트 측에서** 여러 마이크로 프론트엔드 모듈을 런타임에 동적으로 조합하는 방식입니다. 각 마이크로 프론트엔드는 독립적인 자바스크립트 번들로 제공되며, 클라이언트가 페이지를 로드할 때 이 모듈들을 동적으로 가져와서 조합합니다.

### **작동 방식**

- 브라우저가 페이지를 로드하면 필요한 마이크로 프론트엔드 모듈들을 별도의 경로에서 가져와 실행하고 조합합니다.
- 각 모듈은 독립적으로 개발 및 배포되며, 런타임에 동적으로 로드됩니다.

### **장점**

- 독립적인 배포가 가능하여, 각 모듈이 별도로 업데이트될 수 있습니다.
- 런타임에 동적으로 필요한 모듈만 로드하므로, 초기 로딩 시간을 최적화할 수 있습니다.

### **단점**

- 초기 페이지 로딩 성능이 저하될 수 있으며, 각 모듈을 동적으로 로드하는 과정에서 지연이 발생할 수 있습니다.
- 모듈 간의 통신과 상태 공유가 복잡해질 수 있습니다.

### **사용 사례**

- 독립적인 모듈 배포와 업데이트가 중요한 경우.
- 인터랙티브하고 동적으로 구성되는 페이지를 필요로 하는 경우.

# **iFrame을 통한 통합**

각 마이크로 프론트엔드를 독립적인 **iFrame**으로 감싸서 페이지에 삽입하는 방식입니다. 각 마이크로 프론트엔드는 독립적으로 동작하며, 자체적인 스타일과 스크립트를 가집니다.

### **작동 방식**

- 각 마이크로 프론트엔드 모듈은 독립적인 애플리케이션으로 개발되고, iFrame을 통해 최종 애플리케이션에 삽입됩니다.
- 각 iFrame은 완전히 격리된 환경에서 동작하며, 모듈 간의 상호작용은 메시지 패싱 등을 통해 이루어집니다.

### **장점**

- 완벽한 격리가 가능하며, 모듈 간의 스타일 충돌이나 스크립트 충돌이 발생하지 않습니다.
- 각 마이크로 프론트엔드는 독립적으로 동작하며, 상호작용에 대한 안전성을 보장합니다.

### **단점**

- iFrame 간의 통신이 복잡하고 비효율적일 수 있습니다.
- SEO와 성능에 불리할 수 있으며, 페이지 로딩 시간이 길어질 수 있습니다.

### **사용 사례**

- 완벽한 격리가 필요하거나, 여러 모듈의 기술 스택이 크게 다를 때.
- 다른 시스템에서 제공하는 프론트엔드를 통합해야 하는 경우.

# **Webpack의 모듈 페더레이션 (Module Federation)**

**Webpack 5의 모듈 페더레이션** 기능을 활용하여 여러 마이크로 프론트엔드를 동적으로 가져와 조합하는 방식입니다. 각 프론트엔드는 자신의 모듈을 외부에 제공하거나 다른 모듈을 가져올 수 있습니다.

### **작동 방식**

- 각 마이크로 프론트엔드는 자신의 번들을 만들어 제공하고, 필요할 때 다른 마이크로 프론트엔드의 모듈을 가져와서 사용할 수 있습니다.
- 런타임에 동적으로 모듈을 로드할 수 있어 빌드 타임 통합보다 유연하게 동작합니다.

### **장점**

- 독립적인 배포와 유지 보수가 가능하며, 모듈을 런타임에 동적으로 로드할 수 있습니다.
- 중복된 코드를 줄이고, 공통 모듈을 공유할 수 있습니다.

### **단점**

- 초기 설정과 구성 과정이 복잡할 수 있으며, 모듈 간의 의존성 관리에 주의가 필요합니다.
- 잘못 설정하면 성능 저하를 초래할 수 있습니다.

### **사용 사례**

- 독립적인 모듈 개발 및 배포가 필요한 대규모 애플리케이션.
- 모듈 간의 동적 공유가 필요한 프로젝트.

---

[[SaaS] Micro Frontends를 위해 Module Federation 적용하기](https://blog.gangnamunni.com/post/saas-microfrontends/)

[마이크로프론트엔드의 모든 것: 장단점, 도입 시기, 그리고 구현 방법](https://f-lab.kr/blog/everything-about-the-microfrontend)


