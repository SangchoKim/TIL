# 10/17 - Microfrontend vs Monorepos

프론트엔드 개발은 시간이 지남에 따라 점점 더 복잡해지고 있으며, 성능이 뛰어나고 확장 가능하며 유지 보수 가능한 애플리케이션을 구축하기 위해서는 올바른 아키텍처 접근 방식과 개발 전략을 선택하는 것이 필수적입니다.

현대의 복잡한 프론트엔드 애플리케이션을 구조화하고 개발하는 데 있어 **마이크로 프론트엔드**와 **모노레포**는 주목을 받아왔습니다. 그러나 두 가지 접근 방식 모두 장점과 단점이 있으며, 이들이 서로를 어떻게 보완하는지 이해하는 것이 중요한 결정을 내리는 데 도움이 됩니다.

# **What Is a Micro-Frontend?**

마이크로 프론트엔드를 살펴보기 전에, 프론트엔드 애플리케이션을 구축하는 전통적인 모놀리식(monolithic) 아키텍처를 먼저 이해해 보겠습니다.

모놀리식 애플리케이션에서는 모든 코드가 하나의 단위로 묶여 배포됩니다. 따라서 애플리케이션의 아주 작은 변경 사항을 적용하고자 할 때에도 전체 애플리케이션을 다시 빌드하고 배포해야 합니다.

이 과정은 매우 느리고 때로는 비용이 많이 들며, 제대로 처리되지 않으면 애플리케이션 사용자들에게 많은 버그와 다운타임을 야기할 수 있습니다. 모놀리식 아키텍처의 이러한 비효율성으로 인해 마이크로 프론트엔드가 도입되었습니다.

**마이크로 프론트엔드**는 독립적으로 전달 가능한 프론트엔드 애플리케이션 기능들을 조합하여 전체 애플리케이션을 구성하는 소프트웨어 아키텍처 접근 방식입니다. 마이크로 프론트엔드 애플리케이션에서는 프론트엔드 애플리케이션이 더 작은 애플리케이션이나 모듈로 분해되며, 이러한 각 모듈은 서로 독립적인 애플리케이션으로, 다른 팀들이 다른 기술을 사용해 개발, 테스트 및 배포할 수 있습니다.

백엔드 개발에 익숙하다면, **마이크로 프론트엔드**는 마이크로서비스의 개념을 프론트엔드에 확장한 것이라고 볼 수 있습니다. 두 아키텍처는 유사한 개념을 가지고 있으며, 프론트엔드를 더 작고 관리하기 쉬운 부분으로 나누어 사용자 경험을 더 효과적으로 조정할 수 있는 아키텍처로 등장하게 되었습니다.

마이크로 프론트엔드가 무엇인지 더 잘 이해하기 위해, 아래의 그림을 살펴보겠습니다.

![image.png](/Users/kimsangcho/Downloads/image.png)

위 그림에서는 세 개의 서로 다른 마이크로 프론트엔드가 있습니다. 이 모든 마이크로 프론트엔드는 소스 코드 저장소에서 자율적인 팀들이 구축한 개별 기능들입니다.

이들은 각각 독립적인 책임을 지며, 별도의 빌드 파이프라인을 가지고 독립적인 애플리케이션으로 배포됩니다. 따라서 주황색, 녹색, 보라색 박스는 각각 별도로 배포 가능한 요소이며, 실제로는 이 모든 배포 가능한 요소들이 프로덕션 환경에서 하나로 결합됩니다. 각 마이크로 프론트엔드는 독립적으로 프로덕션에 배포됩니다.

예를 들어, 복잡한 전자상거래 애플리케이션에서 쇼핑 카트, 제품 카탈로그, 체크아웃 페이지, 결제 페이지, 사용자 프로필 페이지와 같은 기능별로 별도의 마이크로 프론트엔드를 가질 수 있습니다. 이러한 기능들은 독립적으로 개발, 확장, 테스트 및 배포될 수 있습니다.

각 모듈에 대해 다른 확장 전략을 사용할 수 있으며, 전체 애플리케이션을 확장하지 않고도 하나의 모듈을 더 많은 트래픽을 처리할 수 있도록 확장할 수 있습니다. 모든 사용자가 애플리케이션에 방문할 때 반드시 방문하는 페이지인 제품 카탈로그 페이지는 더 많은 트래픽을 처리할 수 있도록 확장할 수 있는 반면, 프로필 페이지와 같은 다른 페이지는 그럴 필요가 없습니다.

또 다른 시나리오로, 사용자 프로필 페이지에 변경 사항을 적용했는데 해당 페이지가 제대로 작동하지 않는 경우가 생긴다면, 전체 애플리케이션에는 영향을 미치지 않습니다. 사용자는 여전히 제품 카탈로그나 쇼핑 카트 페이지를 방문할 수 있습니다.

## **Pros of Micro-Frontends**

### **팀의 자율성**

전통적인 모놀리식 프론트엔드 아키텍처와 달리, 마이크로 프론트엔드는 여러 팀이 애플리케이션의 다양한 모듈에서 독립적으로 작업할 수 있게 합니다. 프로젝트에 참여하는 개발자들은 각각의 팀으로 나뉘어, 각 팀이 애플리케이션의 일부분을 구상부터 프로덕션까지 책임질 수 있습니다. 이는 각 팀에 더 많은 소유권을 부여하며, 팀은 자신들의 작업에 가장 적합한 기술, 코딩 스타일 및 아키텍처를 선택할 수 있습니다. 이로 인해 제품의 적시 배포가 가능해집니다.

### **기술 선택**

각 애플리케이션을 모듈 단위로 독립적으로 개발하고 유지 관리할 수 있기 때문에, 마이크로 프론트엔드는 애플리케이션의 다른 부분에 가장 적합한 프론트엔드 기술과 프레임워크를 사용할 수 있게 합니다. 이는 호스트 페이지를 Vue로 작성하고, 다른 모듈을 React로 작성하는 것도 가능하다는 것을 의미합니다. 단, 이들이 마이크로 프론트엔드 표준을 유지하는 한 문제는 없습니다. 그 결과, 팀들은 특정 기술 스택에 제약받지 않고, 자신들의 요구에 가장 적합한 기술을 선택할 수 있습니다.

### **독립적인 배포**

마이크로 프론트엔드는 여러 모듈이 각기 다른 빌드를 가지고 있기 때문에 프론트엔드 모듈을 독립적으로 배포할 수 있게 합니다. 각 마이크로 프론트엔드에 대해 지속적인 배포 파이프라인이 있어야 하며, 이는 코드가 어디에 호스팅되든 상관없이 빌드, 테스트 및 배포를 담당합니다. 그 결과, 전체 애플리케이션을 다시 배포할 필요 없이 변경된 부분만 다시 배포할 수 있습니다. 다른 팀이 작업 중인 내용은 다른 팀에 영향을 미치지 않아야 합니다.

### **빠른 구현 및 개발**

마이크로 프론트엔드는 각 기능을 독립적으로 구현할 수 있게 하여 개발 속도를 크게 향상시킵니다. 기능을 변경하거나 추가할 때 전체 애플리케이션을 실행할 필요가 없습니다. 그 결과, 엔지니어들은 프론트엔드 애플리케이션을 더 빠르고 수월하게 구축할 수 있으며, 구현 시간이 크게 단축됩니다.

### **확장성**

마이크로 프론트엔드 아키텍처의 중요한 구성 요소는 모듈성으로, 애플리케이션을 더 작고 독립적인 단위로 분할할 수 있는 능력을 의미합니다. 각 모듈 또는 컴포넌트는 독립적으로 확장될 수 있으며, 애플리케이션 전체는 더 많은 마이크로 프론트엔드를 추가함으로써 확장할 수 있습니다.

이로 인해 확장성이 촉진됩니다. 프로젝트의 기능이 확장됨에 따라 애플리케이션도 쉽게 확장할 수 있으며, 마이크로 프론트엔드를 통해 새로운 팀, 자원 또는 기능을 추가할 수 있습니다. 각 팀은 동시에 서로 다른 특정 모듈을 작업하여 애플리케이션이 진화하는 제품 요구 사항을 원활하게 충족할 수 있도록 확장됩니다.

## **Cons of Micro-Frontends**

### **복잡성 증가**

마이크로 프론트엔드 아키텍처는 제대로 구현되지 않으면 애플리케이션의 복잡성을 크게 증가시킬 수 있습니다. 모듈 간의 상호 컴포넌트 통신과 분리된 컴포넌트 또는 마이크로 파트의 배포를 조율하는 작업이 복잡해질 수 있으며, 이를 유지하기 위해 추가적인 노력과 기술 스택이 필요할 수 있습니다. 마이크로 프론트엔드를 구현하려면 해당 작업을 수행하는 팀 간의 많은 조정이 요구됩니다.

### **라우팅**

라우팅을 통해 URL을 기반으로 요청을 어디로 보낼지 결정할 수 있습니다. 즉, 요청 경로명을 기준으로 웹 서버가 어느 애플리케이션 세그먼트를 실행할지 지시합니다. 이는 데이터 아키텍처와 사용자 경험의 중요한 측면이며, 프론트엔드 애플리케이션을 설계할 때 가장 어려운 부분 중 하나입니다.

사실, 분리된 프론트엔드 경험을 조율하는 것은 더욱 어려워질 수 있으며, 특히 중첩된 컴포넌트의 경로를 사용자에게 노출해야 할 때 그러합니다.

동일한 호스트에서 여러 마이크로 애플리케이션이 실행되는 경우, 각 애플리케이션에 대해 올바르게 작동하도록 라우팅을 구성하는 것이 필수적입니다.

### **페이로드**

JavaScript 번들이 독립적으로 빌드되면 공통 종속성이 중복되어, 네트워크를 통해 최종 사용자에게 전달해야 하는 바이트 수가 증가하게 됩니다.

예를 들어, 마이크로 프론트엔드가 특정 프로그램을 설치해야 기능을 수행할 수 있다면, 최종 사용자는 해당 프로그램의 사본을 다운로드해야 할 것입니다. 즉, 각 마이크로 프론트엔드가 자신의 React 사본을 포함하고 있으면, 최종 사용자는 React를 여러 번 다운로드해야 합니다.

이는 페이지 성능에 직접적인 영향을 미치며, 특히 인터넷 인프라가 열악한 지역에 사는 사용자들의 참여에 영향을 줄 수 있습니다. 페이지 성능이 저하된 애플리케이션에 사용자는 다시 방문하지 않을 수 있으므로, 다운로드 크기를 신중히 고려하는 것이 중요합니다.

## **When to Use Micro-Frontends**

### **대규모 및 복잡한 애플리케이션**

마이크로 프론트엔드는 여러 기능을 가진 중대형 프론트엔드 애플리케이션을 구축하고 유지 관리하는 데 적합합니다. 마이크로 프론트엔드를 통해 애플리케이션을 더 작고 관리하기 쉬운 모듈로 분해할 수 있으므로, 시간이 지남에 따라 애플리케이션이 복잡해질 때 확장하고 유지 관리하기가 더 수월해집니다.

또한, 프론트엔드 애플리케이션은 종종 확장성 문제에 직면하는데, 마이크로 프론트엔드의 장점 중 하나는 특정 모듈을 독립적으로 확장할 수 있어 매우 반응성이 뛰어나고 성능이 우수한 애플리케이션을 만들 수 있다는 점입니다.

### **여러 독립적인 팀**

여러 팀이 협력해야 하는 매우 복잡한 애플리케이션을 구축할 때 마이크로 프론트엔드를 사용하는 것이 좋습니다. 마이크로 프론트엔드 접근 방식은 각 팀이 애플리케이션의 다른 부분을 구축하는 데 책임을 지며, 자율적으로 작업할 수 있는 이상적인 방법입니다.

### **여러 기술 스택**

서로 다른 기술 스택을 사용하는 다양한 자율 팀이 애플리케이션을 구축하는 경우 마이크로 프론트엔드를 사용하는 것이 적합합니다. 마이크로 프론트엔드는 독립적인 모듈을 작업하는 각 팀이 자신들의 요구에 가장 적합한 기술을 선택할 수 있는 유연성을 제공합니다. 이를 통해 새로운 기술을 쉽게 도입하거나 기존 레거시 시스템에서 점진적으로 전환하는 데 매우 유용할 수 있습니다.

# **What Is a Monorepo?**

**모노레포**는 여러 프로젝트의 코드를 동일한 저장소에 저장하는 소프트웨어 개발 전략입니다. 이름에서 알 수 있듯이, '모노레포'는 하나의(mono) 코드 저장소에 여러 프로젝트가 포함되어 있기 때문에 붙여진 이름입니다.

그러나 개별 프로젝트는 전통적인 모놀리식 아키텍처와 달리, 각각 별도의 생명 주기를 가집니다. 모노레포는 마이크로 프론트엔드를 사용하지 않고도 단일 저장소에서 여러 프로젝트를 관리하는 방법입니다.

모노레포가 모든 문제를 해결해주는 만능 해결책은 아닙니다. 현재 코드베이스에서 어떤 문제가 발생하고 있으며, 그것이 확장되지 않는 이유를 파악한 후에 모노레포를 사용할지 결정해야 합니다.

모노레포를 사용하면 단일 저장소에 여러 마이크로 프론트엔드 애플리케이션을 만들 수 있으며, 이러한 개별 마이크로 프론트엔드를 각각의 런타임에서 별도의 생명 주기로 배포할 수 있습니다. 마이크로 프론트엔드를 모노레포와 결합하면 마이크로 프론트엔드 구현과 관련된 복잡성의 일부를 해결할 수 있습니다.

모노레포는 때때로 **모놀리식 저장소**라고도 불립니다. 그러나 셀프 컨테이너 애플리케이션을 구축하는 데 사용되는 **모놀리식 아키텍처**와는 혼동해서는 안 됩니다.

또한, 모노레포는 **멀티레포**와는 정반대 개념이라는 점도 중요합니다. 모노레포는 여러 프로젝트를 포함한 단일 저장소(전체 코드베이스를 포함한 큰 폴더 하나를 생각하면 됩니다)를 의미하는 반면, 멀티레포는 각각의 프로젝트가 별도의 저장소를 가진 구조를 말합니다.

모노레포는 구글이 Gmail과 YouTube에 단일 저장소를 사용한다고 공개했을 때 매우 인기를 얻었습니다. 실제로 구글은 모노레포 패러다임을 사용해 코드 구조를 조직하고 있습니다. Facebook, Twitter, Uber, Netflix 등 다른 기업들도 모노레포를 사용하고 있습니다.

## **Pros of Monorepos**

### **협업의 용이성**

모노레포는 전체 코드베이스가 하나의 저장소에 있기 때문에 팀 간의 협업을 더 쉽게 만듭니다. 모든 것이 한 곳에 있기 때문에 변경 사항을 추적하고 코드를 공유하기가 더 쉬워지고, 모든 사람들이 원활하게 협업할 수 있습니다.

### **단순화된 의존성 관리**

모노레포는 의존성 관리를 단순화합니다. 비록 의존성이 개별적으로 빌드되거나 애플리케이션과 별도로 위치하더라도, 같은 저장소 안에서 쉽게 사용할 수 있기 때문입니다. 또한, 모든 모듈이 단일 저장소에 호스팅되고 소싱되기 때문에 의존성 충돌을 방지할 수 있습니다. 또한, 하나의 `package.json` 파일만 존재하기 때문에 의존성을 업데이트할 때마다 각 저장소에 의존성을 설치할 필요가 없습니다.

### **리팩토링**

모노레포에서는 리팩토링이 더 쉽습니다. 시스템 전체에 걸쳐 여러 프로젝트에서 무언가를 리팩토링하려면, 모든 것이 하나의 저장소와 하나의 파일 시스템에 있는 것이 훨씬 더 편리합니다.

각 저장소에 대해 개별적으로 풀 리퀘스트를 작성하고 변경 사항을 어떤 순서로 빌드할지 고민하는 대신, 작업 중인 기능과 관련된 모든 커밋을 포함하는 하나의 원자적 풀 리퀘스트만 만들면 됩니다.

## **Cons of Monorepos**

### **느린 Git 작업**

Git 작업은 매우 느려질 수 있습니다. 수백만 줄의 코드와 커밋, 그리고 무한 반복되는 시스템 전체의 작업이 하나의 저장소에 있고, 여러 엔지니어가 동시에 동일한 저장소에서 협업하는 상황을 상상해 보십시오.

모노레포는 대규모 애플리케이션에서 발생하는 문제를 추적하고 신속하게 해결하기 어렵기 때문에 Git 저장소 통합이 더 복잡해집니다.

### **파이프라인 문제**

여러 저장소가 있을 경우 파이프라인을 생성하는 것이 비교적 간단합니다. 저장소 중 하나에서 변경이 발생하면 파이프라인을 트리거하고, 필요한 작업을 실행합니다. 아티팩트를 빌드하고, 이를 레지스트리에 푸시하며, 테스트를 실행하고, 특정 위치에 배포하는 등의 작업이 이루어집니다.

그러나 모노레포를 사용할 경우, 파이프라인을 실행하는 것이 더 복잡해집니다. 누군가가 모노레포에 변경을 가하면, 파이프라인은 어떤 작업을 수행할지, 무엇이 변경되었는지, 해당 변경으로 인해 어떤 작업을 트리거해야 하는지, 무엇을 빌드하고 빌드하지 말아야 하는지를 파악해야 합니다. 이러한 작업은 금세 복잡해질 수 있습니다.

### **풀 리퀘스트 할당**

또 다른 문제는 풀 리퀘스트입니다. 모노레포는 많은 잡음을 유발하며, 저장소 간 분리가 없는 상황에서 풀 리퀘스트를 검토하고 병합하는 작업을 분배하는 것이 어려울 수 있습니다. 풀 리퀘스트가 생성되면 어떻게 해야 할까요?

동일한 저장소에서 많은 사람들이 풀 리퀘스트를 생성하는 상황에서 어떤 풀 리퀘스트를 검토해야 하는지, 그리고 누가 검토해야 하는지를 어떻게 파악할 수 있을까요? 이는 특히 섬세한 작업을 할 때 매우 복잡해질 수 있습니다.

### **긴 빌드 및 테스트 시간**

코드베이스가 커지면서 빌드 및 테스트 과정이 상당히 길어질 수 있으며, 많은 코드가 한 곳에 모여 있기 때문에 지속적 통합(CI) 과정에서 모든 PR을 승인하는 데 더 많은 시간이 소요될 수 있습니다.

# **Conclusion**

마이크로 프론트엔드와 모노레포의 개념을 살펴보고, 그 장점과 단점에 대해 논의했습니다. 마이크로 프론트엔드는 더 작고 관리하기 쉬운 부분들을 기반으로 확장 가능한 프론트엔드 애플리케이션을 개발하는 방법입니다. 이러한 모듈 각각은 별도의 애플리케이션으로, 서로 다른 팀이 서로 다른 기술을 사용하여 개발하고, 독립적으로 테스트 및 배포할 수 있습니다.

마이크로 프론트엔드의 주요 목표는 **격리**입니다. 이 격리 덕분에 개별 모듈을 독립적으로 구현하여 전체 애플리케이션을 구성할 수 있습니다. 마이크로 프론트엔드의 격리 개념은 매우 유용하지만, 라이브러리의 공유 및 관리는 추가적인 작업을 필요로 합니다. 그러나 여러 마이크로 프론트엔드를 수용할 수 있는 모노레포는 이러한 작업을 단순화할 수 있습니다.

마이크로 프론트엔드를 사용할 때 재사용성, 의존성 관리 및 성능과 같은 여러 가지 도전 과제가 발생할 수 있습니다. 이러한 문제를 해결하는 방법 중 하나는 모노레포를 활용하는 것입니다. 모노레포는 여러 프로젝트를 포함하는 단일 저장소로서, 중앙 집중식 의존성 관리, 관리하기 쉬운 버전 관리, 빠른 개발 반복과 같은 이점을 제공합니다.

---

[React Basics: Microfrontend vs. Monorepos](https://www.telerik.com/blogs/react-basics-microfrontend-vs-monorepos)


